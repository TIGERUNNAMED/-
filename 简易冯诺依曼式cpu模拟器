#include<stdio.h>
long long memory[384]={0};
long long ip=0,ir=0,flag=0,ax[9]={0};/*以数组模拟内存，模拟寄存器*/
void read();/*读入指令函数*/ 
void operate();/*操作函数*/ 
int get(int i);/*取指令&分析函数*/ 
void output1();/*逐步输出寄存器函数*/ 
void output2();/*内存输出函数*/ 
int stop(int i);/*停机指令*/ 
int deliver(int i,long long p1,long long p2,long long immediate);/*数据传输指令*/
int plus(int i,long long p1,long long p2,long long immediate);/*运算指令加法*/ 
int minus(int i,long long p1,long long p2,long long immediate);/*减法*/ 
int multiply(int i,long long p1,long long p2,long long immediate);/*乘法*/ 
int divide(int i,long long p1,long long p2,long long immediate);/*除法*/ 
int logicand(int i,long long p1,long long p2,long long immediate);/*逻辑与*/ 
int logicor(int i,long long p1,long long p2,long long immediate);/*逻辑或*/ 
int logicnot(int i,long long p1,long long p2,long long immediate);/*逻辑非*/ 
int compare(int i,long long p1,long long p2,long long immediate);/*比较指令*/ 
int jump(int i,long long p1,long long p2,long long immediate);/*跳转指令*/ 
int input(int i,long long p1,long long p2,long long immediate);/*输入指令*/ 
int out(int i,long long p1,long long p2,long long immediate);/*输出指令*/ 
int main()/*主函数*/ 
{
	read();
	operate();
	output2();
	return 0;
 } 
 void read()/*读入指令函数*/
 {
 	int i=0;
    FILE *fptr;
 	fptr=fopen("dict.dic","r");
    while(!feof(fptr)&&i<128)
    { int c=0,j=0;
      long long temp=0;
      while(j<32)
      { c=fgetc(fptr);
        if(c==48||c==49)
		{temp=temp*2+c-48;}/*转化为十进制数*/ 
        j++;
      }
      c=fgetc(fptr);/*跳过换行符*/
      if(i==0||memory[i-1]!=0)/*判断是否读到停机指令，若否写入内存*/ 
      memory[i]=temp;
      i++;
    }
	fclose(fptr);
 }
 void operate()/*操作函数*/ 
 {
  int i=0; 
  while((memory[i]!=0||memory[i-1]!=0)&&i<128)/*逐条取出指令*/ 
  {
   i=get(i);
   output1();
  }

 }
int get(int i)/*取指令&分析函数*/
 { 	
  long long  temp=memory[i];
  long long x; 
  x=temp/16777216;/*除以2^24的商以作为判别指令类的型标准*/
  long long immediate,p1,p2;/*立即数 操作对象1，2*/ 
  int bor;/*辅助变量，判断立即数正负*/
  p1=(temp%16777216)/1048576;
  p2=(temp%1048576)/65536;
  bor=(temp%65536)/32768;
  if (bor==0) immediate= temp%32768;
  if (bor==1) immediate= temp%32768-32768;/*根据进制转换和补码运算规则分别算出p1p2和立即数*/ 
  if (x==0&&temp==0) i=stop(i);
  if (x==1) i=deliver(i,p1,p2,immediate);
  if (x==2) i=plus(i,p1,p2,immediate);
  if (x==3) i=minus(i,p1,p2,immediate);
  if (x==4) i=multiply(i,p1,p2,immediate);
  if (x==5) i=divide(i,p1,p2,immediate);
  if (x==6) i=logicand(i,p1,p2,immediate);
  if (x==7) i=logicor(i,p1,p2,immediate);
  if (x==8) i=logicnot(i,p1,p2,immediate);
  if (x==9) i=compare(i,p1,p2,immediate);
  if (x==10) i=jump(i,p1,p2,immediate);
  if (x==11) i=input(i,p1,p2,immediate);
  if (x==12) i=out(i,p1,p2,immediate);
  return i;
 }
 void output1()/*逐步输出寄存器函数*/ 
 {
 	printf("ip = %d\n",ip);
 	printf("flag = %d\n",flag);
 	printf("ir = %d\n",ir);
 	printf("ax1 = %d ax2 = %d ax3 = %d ax4 = %d\n",ax[1],ax[2],ax[3],ax[4]);
 	printf("ax5 = %d ax6 = %d ax7 = %d ax8 = %d\n",ax[5],ax[6],ax[7],ax[8]);
 	 	
 }
 void output2()/*内存输出函数*/
 {
 	int i=0;
 	printf("\n");/*指令段*/ 
 	printf("codeSegment :\n");
 	while(i<128)
 	{
 		int j=0;
 		while(j<8)
 		{printf("%lld",memory[i]);
 		 if (j<7) printf(" ");
		 j++;
		 i++;}
		 printf("\n");
	 } 
	printf("\n");
 	printf("dataSegment :\n");/*数据段*/ 
 	i=128;
 	while(i<384)
 	{
 		int j=0;
 		while(j<16)
 		{
 			printf("%lld",memory[i]);
 			if (j<15) printf(" ");
 			j++;
 			i++;
		 }
		printf("\n");	
	 }
 }
int stop(int i)/*停机指令*/
{
i++;
ip=ip+4;
ir=0;
return i;	
}
int deliver(int i,long long p1,long long p2,long long immediate)/*数据传输指令*/
{
	if (p2==0) ax[p1]=immediate;
	if (p2>=5)
    {
	  int c=(ax[p2]-16384)/2+128;/*数组下标转换*/ 
	  ax[p1]=memory[c];
    }
	if (p2<5&&p1>=5&&p2!=0)
	{
	  int c=(ax[p1]-16384)/2+128;
	  memory[c]=ax[p2];		
	}
	ip+=4;
	ir=memory[i]/65536;
	i++;
return i;	
}
int plus(int i,long long p1,long long p2,long long immediate)/*运算指令加法*/
{
	if(p2==0) ax[p1]=ax[p1]+immediate;
	if(p2>=5) 
	{
	  int c=(ax[p2]-16384)/2+128;/*数组下标转化*/
	  ax[p1]=ax[p1]+memory[c];/*注意到是与数据加*/
	}
	ip+=4;
	ir=memory[i]/65536;
	i++;
    return i;	
}
int minus(int i,long long p1,long long p2,long long immediate)/*减法*/ 
{
	if(p2==0) ax[p1]=ax[p1]-immediate;
	if(p2>=5) 
	{int c=(ax[p2]-16384)/2+128;
	ax[p1]=ax[p1]-memory[c];
	}
	ip+=4;
	ir=memory[i]/65536;
	i++;
return i;	
}
int multiply(int i,long long p1,long long p2,long long immediate)/*乘法*/ 
{
	if(p2==0) ax[p1]=ax[p1]*immediate;
	if(p2>=5)
	{int c=(ax[p2]-16384)/2+128;
	ax[p1]=ax[p1]*memory[c];
	}
	ip+=4;
	ir=memory[i]/65536;
	i++;
return i;	
}
int divide(int i,long long p1,long long p2,long long immediate)/*除法*/ 
{
	if(p2==0) ax[p1]=ax[p1]/immediate;
	if(p2>=5)
	{int c=(ax[p2]-16384)/2+128;
	ax[p1]=ax[p1]/memory[c];	
	}
	ip+=4;
	ir=memory[i]/65536;
	i++;
return i;	
}
int logicand(int i,long long p1,long long p2,long long immediate)/*逻辑与*/ 
{
	if(p2==0) ax[p1]=(ax[p1]&&immediate);
	if(p2>=5&&p1!=0) 
	{
	  int c=(ax[p2]-16384)/2+128;
	  ax[p1]=(ax[p1]&&memory[c]);
    }
	ip+=4;
	ir=memory[i]/65536;
	i++;
return i;	
}
int logicor(int i,long long p1,long long p2,long long immediate)/*逻辑或*/ 
{
	if(p2==0) ax[p1]=(ax[p1]||immediate);
	if(p2>=5&&p1!=0) 
	{ int c=(ax[p2]-16384)/2+128;/*数组下标转化*/
	  ax[p1]=(ax[p1]||memory[c]);
    }
	ip+=4;
	ir=memory[i]/65536;
	i++;
return i;	
}
int logicnot(int i,long long p1,long long p2,long long immediate)/*逻辑非*/ 
{
	if(p2==0) ax[p1]=(!ax[p1]);
	if(p1==0) 
	{int c=(ax[p2]-16384)/2+128;/*数组下标转化*/ 
	memory[c]=(!memory[c]);/*注意到是数据做非运算*/
    }
	ip+=4;
	ir=memory[i]/65536;
	i++;
return i;	
}
int compare(int i,long long p1,long long p2,long long immediate)/*比较指令*/ 
{
	if(p2==0) 
	{ if(ax[p1]==immediate) flag=0;
	  if(ax[p1]>immediate) flag=1;	
	  if(ax[p1]<immediate) flag=-1;		
	}
	if(p2>=5) 
	{ int c=(ax[p2]-16384)/2+128;
      if(ax[p1]==memory[c]) flag=0;/*注意到是与数据比较*/ 
	  if(ax[p1]>memory[c]) flag=1;	
	  if(ax[p1]<memory[c]) flag=-1;
	}
	ip=ip+4;
	ir=memory[i]/65536;
	i++;
return i;	
}
int jump(int i,long long p1,long long p2,long long immediate)/*跳转指令*/ 
{ 
    ir=memory[i]/65536;/*对ip操作在对数组下标操作之前*/ 
	if(p1==p2&&p1==0) 
	{ip=ip+immediate;
	i+=immediate/4;/*转化下标*/ 
	}
	else if(p2==1&&flag==0)
	{ip=ip+immediate;
	i+=immediate/4;
	}
	else if(p2==2&&flag==1)
	{ip=ip+immediate;
	i+=immediate/4;	
	}
	else if(p2==3&&flag==-1)
	{ip=ip+immediate;
	i+=immediate/4;	
	}
	else
	{ip+=4;
	i++;
	}
    return i;	
}
int input(int i,long long p1,long long p2,long long immediate)/*输入指令*/ 
{
	printf("in:\n");
	scanf("%lld",&ax[p1]);
	ip+=4;
	ir=memory[i]/65536; 
	i++;
return i;	
}
int out(int i,long long p1,long long p2,long long immediate)/*输出指令*/ 
{
	printf("out: %d\n",ax[p1]);
	ip+=4;
	ir=memory[i]/65536;
	i++;
    return i;	
}
